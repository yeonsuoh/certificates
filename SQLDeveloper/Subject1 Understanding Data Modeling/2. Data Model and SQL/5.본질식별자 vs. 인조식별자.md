# 본질식별자 vs. 인조식별자

* 인조식별자는 대체로 본질식별자가 복잡한 구성을 가질 때 만들어진다.
* 인조식별자를 사용하면 중복데이터를 막기 어려워진다.
* 인조식별자를 사용하면 본질식별자를 사용할 때와 비교하여 추가적인 인덱스가 필요해진다.
* 인조식별자는 단점도 존재하므로 꼭 필요한 경우에만 사용하는 것이 바람직하다.

**본질식별자 (Natural Identifier)**
* 정의:
  * 본질적 속성 기반: 엔터티의 고유성을 보장하는 자연적인 속성(또는 속성의 조합)을 사용하여 엔터티를 식별합니다.
  * 의미 있는 값: 실제 데이터를 나타내는 의미 있는 값을 가지며, 외부에서도 유효하고 이해될 수 있는 값입니다.
* 예시:
 * 주민등록번호, ISBN(도서의 고유 번호), 제품 일련 번호 등.

**인조식별자 (Surrogate Identifier)**
* 정의:
  * 인조적 값 기반: 시스템에서 자동으로 생성한 고유한 식별자를 사용하여 엔터티를 식별합니다. 일반적으로 숫자나 UUID를 사용합니다.

  * 의미 없는 값: 그 자체로는 아무런 의미가 없고, 데이터베이스 내부에서만 사용됩니다.
* 예시:
* 데이터베이스 테이블의 기본 키로 사용되는 자동 증가 숫자(예: 1, 2, 3...).

**인조식별자를 사용할 때 중복 데이터를 막기 어려운 이유**
* 인조식별자를 사용할 때 중복 데이터를 막기 어려워질 수 있다는 말은 다음과 같은 상황을 의미할 수 있습니다:
  * 본질적 고유성 확인 부족: 인조식별자는 본질적으로 고유하지만, 데이터 자체의 중복을 막지는 않습니다. 예를 들어, 두 명의 고객이 동일한 이름과 생년월일을 가지고 있어도 각기 다른 인조식별자를 부여받을 수 있습니다.
본질식별자를 사용할 경우, 이름과 생년월일이 동일한 데이터가 입력되면 중복으로 간주하여 입력을 막을 수 있습니다.
  * 데이터 무결성 문제: 인조식별자는 데이터의 고유성을 보장하는 것이 아니라 단순히 레코드를 구분하기 위해 사용됩니다. 따라서 같은 데이터가 여러 번 입력되는 경우를 방지하지 못합니다.
본질식별자는 데이터의 특정 속성을 기반으로 하므로, 중복 데이터를 자연스럽게 배제할 수 있습니다.

* 예시로 이해하기:
  * 본질식별자 사용 시:
    * 고객 테이블:
      - 주민등록번호 (본질식별자)
      - 이름
      - 주소

주민등록번호가 본질식별자이므로, 동일한 주민등록번호를 가진 두 개의 레코드를 입력할 수 없습니다. 즉, 중복 데이터 입력이 방지됩니다.
  * 인조식별자 사용 시:
    * 고객 테이블:
      - 고객 ID (인조식별자)
      - 이름
      - 주소

고객 ID가 인조식별자이므로, 이름과 주소가 동일한 레코드를 여러 개 입력할 수 있습니다. 이 경우, 중복 데이터가 발생할 수 있습니다.

* 결론
  * 인조식별자를 사용하면 레코드의 고유성을 보장할 수 있지만, 데이터의 본질적인 고유성을 보장하지 못하여 중복 데이터 입력을 막기 어렵습니다. 따라서, 데이터의 고유성을 보장하고 중복을 방지하기 위해서는 인조식별자와 함께 본질식별자(또는 유니크 제약 조건)를 사용하는 것이 좋습니다.